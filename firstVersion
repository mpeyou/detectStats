function [avgWidth, stdWidth, avgDistBtRising, stdDistBtRising, middleLinePlot,riseEdge, fallEdge] = detectStats(modedData,numSymbols,exact,sampleRate,decimalRound, type)
%//////////////////////////////////////////////////////////////////////////
%// Name: detectStats                                                    //       
%//                                                                      //
%// Call: [avgDistBtRising, stdDistBtRising,avgWidth, stdWidth, avgPos,  //
%//       stdPos, riseEdge, fallEdge,distanceBtFallRise] = detectStats   //
%//       (modedData,numSymbols,samplesPerPeriod,exact,decimalRound,     //
%//       sampleRate)                                                    //         
%//                                                                      //
%// Type: function                                                       //
%//                                                                      //
%// Inputs:                                                              //  
%//       inputData = the input data points (in an array)                //
%//                                                                      //
%//       pulseAmp= amplitude that the high portions of the signal reach //
%//                                                                      //
%//       sampleRate = rate at which the data is sampled, same as above  //
%//                                                                      //
%//       snr=signal to noise ratio,used when adding noise to the signal //
%//                                                                      //
%//       modType => PWM = 1  PPM=2                                      //
%//                                                                      // 
%//                                                                      //
%//                                                                      //
%// Outputs:                                                             //
%//                                                                      //         
%//     avgWidth            = average distance between rising and        //
%//                           falling edges                              //
%//                                                                      //
%//     stdWidth            = standard deviation of distance between     //
%//                           rising and falling edges                   //
%//                                                                      //
%//     avgDistBtRising     = average distance between rising edges      //
%//                                                                      //
%//     stdDistBtRising     = standard deviation of distance between     //
%//                           rising edges                               //
%//     riseEdge            = array of positions where the rising edges  //
%//                           are located within the shortened           //
%//                           modedData(which is then called             //
%//                           shortenedModedData, and now starts         //
%//                           on the first rising edge)                  //
%//                                                                      //
%//     fallEdge            = array of positions where the falling edges //
%//                           are located within the shortened modedData //
%//                           (which is then called shortenedModedData,  //
%//                           and now starts on the first rising edge)   //   
%//                                                                      //
%//    distanceBtFallRise  = array of distances between rising and       //
%//                          falling edges                               //
%//                                                                      //  
%//                                                                      //
%//                                                                      //
%// Description:                                                         //
%//   modulates the data in the form you choose (PWM,PPM) then sends the //
%//   modulated data to detectStats to get statistics about the          //
%//   modulated data                                                     //
%//////////////////////////////////////////////////////////////////////////
%}


%*************************************************************************
%**                      Variable Declaration                           **              
%*************************************************************************

%-----------------------------------------
%//Name:riseEdge
%//Purpose: holds the positions of the rising edges within the shortened 
%//array. Is the size of the number of symbols minus 1 because the
%//shortened data array will cut off the first symbol because it has no
%//rising edge

riseEdge(1) = 0; 

%riseEdge(1)=-1;  
%is a flag that ensures that the second rising edge uses to mark where 
%area (used in finding the pulsePowerMinAverage) stops
%becomes the next first rising edge in
%that pattern

%-----------------------------------------
%//Name:fallEdge
%//Purpose: holds the positions of the rising edges within the shortened 
%//array. Is the size of the number of symbols minus 1 because the
%//shortened data array will cut off the first symbol because it has no
%//rising edge, and therefore theres is one less falling edge
  
 %fallEdge = zeros(1,numSymbols-1);  
 
%----------------------------------------- 
%//Name:distanceBtRisingAndFalling
%//Purpose: holds the distance between consecutive rising and falling edge
%//positions

   distanceBtRisingAndFalling= zeros(1,numSymbols-1);    

%----------------------------------------- 
%//Name:alpha
%//Purpose: controls the rate of change of the middleLine
   
   alpha = 0.95;                                       


%----------------------------------------- 
%//Name:firstTenMillisecondsOfSamples
%//Purpose: is the first ten milliseconds by multiplying the 
%//sample rate(samples per second) by 10/1000 to get 10ms of 
%//samples. Might be not a round number of samples so round to 
%//nearest whole number
  
firstTenMilliseconds = round(0.01*sampleRate,0);

%----------------------------------------- 
%//Name:middleLine
%//Purpose: middleLine is the point at which to check if there is a rising edge
%//between two points

movingMax = max(modedData);
movingMin = min(modedData);

middleLine = (movingMax+movingMin)/2;%+movingMin

middleLinePlot(1:firstTenMilliseconds) = middleLine;
                                                             

%----------------------------------------- 
%//Name:modedDataIndex 
%//Purpose: indexes through the modedData array

 modedDataIndex = 1;    

%----------------------------------------- 
%//Name:edgeIndex
%//Purpose: index for moving through the edge arrays when finding the edge
%//locations
  edgeIndex = 1;

%----------------------------------------- 
    %first edges
    while edgeIndex == 1
    %find the first edge. The following steps will depend on whether the first edge is rising or falling
    %if there is a falling edge first, then riseEdge(1) will be zero, and
    %therefore will determine the method used in determining the movingMax and
    %movingMin. will not increase edgeIndex until there has been a falling
    %index found
        if (modedData(modedDataIndex) < middleLine) && (modedData(modedDataIndex+1) > middleLine)%rising edge
            riseEdge(edgeIndex) = modedDataIndex+1; %is recorded on the high point of the edge
            modedDataIndex = modedDataIndex+1;
        elseif (modedData(modedDataIndex) > middleLine) && (modedData(modedDataIndex+1) < middleLine)%falling edge
            fallEdge(edgeIndex) = modedDataIndex+1;    %is recorded on the low point of the edge
            modedDataIndex = modedDataIndex+1;
            edgeIndex = edgeIndex+1; 
        else
            modedDataIndex = modedDataIndex+1;
        end
    end
    
    leadOffMarker = firstTenMilliseconds; %serves to help mark the middleLinePlot
    %determind which kind of edge the array started on
    if riseEdge(1) ~= 0 %starts on rising edge
        type = 1;
    else 
        type =0;
    end
    %-----------------------------------------------
   
    while (edgeIndex > 1) && (modedDataIndex<= length(modedData)-1)
        %//////////////////////////
        %//Starts on Falling Edge//
        %//////////////////////////
                
                
        if type == 0 %starts on the falling Edge, so when there is a rising edge, increment the edgeIndex
            %find the initial values for moving max, min and average. make sure
            %the average within this time frame stays the same for measurements
                
            %/////////////////////////////////////////
            %//Falling Start: Encounters Rising Edge//
            %/////////////////////////////////////////

            if (modedData(modedDataIndex) < middleLine) && (modedData(modedDataIndex+1) > middleLine)%if is a rising edge
                riseEdge(edgeIndex) = modedDataIndex+1; %is recorded on the high point of the edge
                
                %////////////////////////////
                %//FS:RE:Before first 10 ms//
                %////////////////////////////
                if (modedDataIndex < firstTenMilliseconds) %before first 10 ms
                    movingMinTemp(edgeIndex-1) = mean(modedData(fallEdge(edgeIndex-1):riseEdge(edgeIndex)-1));
                    modedDataIndex = modedDataIndex+1;
                   % edgeIndex = edgeIndex+1;
                
                %//////////////////
                %//FS:RE:At 10 ms//
                %//////////////////
                elseif (modedDataIndex == firstTenMilliseconds) %at end of first 10ms
                    
                    %calculate initial stats
                    middleLinePlot(1:firstTenMilliseconds) = middleLine;
                    
                    
                    movingMin = mean(movingMinTemp);
                    movingMax = mean(movingMaxTemp);
                    middleLine = ((movingMax+movingMin)/2);%+movingMin;
                    modedDataIndex = modedDataIndex+1;
%                     edgeIndex = edgeIndex+1;
                    
                %/////////////////////
                %//FS:RE:After 10 ms//
                %/////////////////////
                else
                    
                    movingMin = (alpha*movingMin)+((1-alpha)*mean(modedData(fallEdge(edgeIndex-1):riseEdge(edgeIndex)-1)));
                    modedDataIndex = modedDataIndex+1;
                    %edgeIndex = edgeIndex+1;
                    
                end
                
                
            %//////////////////////////////////////////
            %//Falling Start: Encounters Falling Edge//
            %/////////////////////////////////////////
            elseif (modedData(modedDataIndex) > middleLine) && (modedData(modedDataIndex+1) < middleLine)%falling edge
                fallEdge(edgeIndex) = modedDataIndex+1; %is recorded on the low point of the edge
                
                %////////////////////////////
                %//FS:FE:Before first 10 ms//
                %////////////////////////////
                if (modedDataIndex < firstTenMilliseconds) %before first 10 ms
                    %keep edgeIndex the same because need
                    %to put in the riseEdge position
                    movingMaxTemp(edgeIndex-1) = mean(modedData(riseEdge(edgeIndex-1)+1:fallEdge(edgeIndex-1)-1));
                    modedDataIndex = modedDataIndex+1;
                    edgeIndex = edgeIndex+1;
                    
                 
                %//////////////////
                %//FS:FE:At 10 ms//
                %/////////////////    
                elseif (modedDataIndex == firstTenMilliseconds) %at end of first 10ms
                    %calculate initial stats
                    middleLinePlot(1:firstTenMilliseconds) = middleLine;
                    
                    movingMin = mean(movingMinTemp);
                    movingMax = mean(movingMaxTemp);
                    middleLine = ((movingMax+MovingMin)/2);%+movingMin;
                    modedDataIndex = modedDataIndex+1;
                    
                %/////////////////////
                %//FS:FE:After 10 ms//
                %/////////////////////    
                else 
                    
                    movingMax = (alpha*movingMax)+((1-alpha)*(mean(modedData(riseEdge(edgeIndex):fallEdge(edgeIndex)-1))));
                    
                    %update the middle line because it will have a new
                    %moving max and min to work with. If need to update as
                    %soon as new max and min, put this statement at the
                    %else of FS:RE
                    
                    
                    
                    %updates middle line after each new moving max and
                    %moving min
                    middleLineTemp = ((movingMax+movingMin)/2);%+movingMin;
                    middleLine = (middleLine*alpha)+((1-alpha)*(middleLineTemp));
                    middleLinePlot(leadOffMarker:modedDataIndex) = middleLine;
                    leadOffMarker= modedDataIndex+1;
                    modedDataIndex = modedDataIndex+1;
                    edgeIndex = edgeIndex+1;
                 
                end
            
            %///////////
            %//No Edge//
            %///////////    
            else %keep moving, there is no edge
                
                modedDataIndex = modedDataIndex+1;
                
            end
            
    %/////////////////////////
    %//Starts on Rising Edge//
    %/////////////////////////      
        elseif type == 1 %starts on the rising Edge, so when there is a falling edge, increment the edgeIndex
            
            
            %////////////////////////////////////////
            %//Rising Start: Encounters Rising Edge//
            %////////////////////////////////////////

            if (modedData(modedDataIndex) < middleLine) && (modedData(modedDataIndex+1) > middleLine)%if is a rising edge
                riseEdge(edgeIndex) = modedDataIndex+1; %is recorded on the high point of the edge
                
                
                %////////////////////////////
                %//RS:RE:Before first 10 ms//
                %////////////////////////////
                if (modedDataIndex < firstTenMilliseconds) %before first 10 ms
                    movingMinTemp(edgeIndex-1) = mean(modedData(fallEdge(edgeIndex-1):riseEdge(edgeIndex)-1));
                    modedDataIndex = modedDataIndex+1;
    
                
                %//////////////////
                %//RS:RE:At 10 ms//
                %//////////////////
                elseif (modedDataIndex == firstTenMilliseconds) %at end of first 10ms
                    %calculate initial stats
                    middleLinePlot(1:firstTenMilliseconds) = middleLine;
                    
                    movingMin = mean(movingMinTemp);
                    movingMax = mean(movingMaxTemp);
                    middleLine = ((movingMax+MovingMin)/2);%+movingMin;
                    modedDataIndex = modedDataIndex+1;
                    
                %/////////////////////
                %//RS:RE:After 10 ms//
                %/////////////////////  
                else
                    movingMin = (alpha*movingMin)+((1-alpha)*(mean(modedData(fallEdge(edgeIndex-1):riseEdge(edgeIndex)-1))));
                    
                    %update the middle line because it will have a new
                    %moving max and min to work with. If need to update as
                    %soon as new max and min, put this statement at the
                    %else of FS:RE
                    
                    
                    
                    %updates middle line after each new moving max and
                    %moving min
                    middleLineTemp = ((movingMax+movingMin)/2);%+movingMin;
                    middleLine = (middleLine*alpha)+((1-alpha)*(middleLineTemp));
                    middleLinePlot(leadOffMarker:modedDataIndex) = middleLine;
                    leadOffMarker= modedDataIndex+1;
                    modedDataIndex = modedDataIndex+1;
                    
                end
            %/////////////////////////////////////////
            %//Rising Start: Encounters Falling Edge//
            %/////////////////////////////////////////
            elseif (modedData(modedDataIndex) > middleLine) && (modedData(modedDataIndex+1) < middleLine)%falling edge
                fallEdge(edgeIndex) = modedDataIndex+1; %is recorded on the low point of the edge
                
                
                %////////////////////////////
                %//RS:FE:Before first 10 ms//
                %////////////////////////////
                if (modedDataIndex < firstTenMilliseconds) %before first 10 ms
                    %keep edgeIndex the same because need
                    %to put in the riseEdge position
                    movingMaxTemp(edgeIndex-1) = mean(modedData(riseEdge(edgeIndex):fallEdge(edgeIndex)-1));
                    modedDataIndex = modedDataIndex+1;
                    edgeIndex= edgeIndex+1;
                
                %//////////////////
                %//RS:FE:At 10 ms//
                %//////////////////   
                elseif (modedDataIndex == firstTenMilliseconds) %at end of first 10ms
                    %calculate initial stats
                    middleLinePlot(1:firstTenMilliseconds) = middleLine;
                    
                    movingMin = mean(movingMinTemp);
                    movingMax = mean(movingMaxTemp);
                    middleLine = ((movingMax+movingMin)/2)+movingMin;
                    edgeIndex= edgeIndex+1;
                    modedDataIndex = modedDataIndex+1;
                    
                %/////////////////////
                %//RS:FE:After 10 ms//
                %/////////////////////    
                else 
                    
                    movingMax = (alpha*movingMax)+((1-alpha)*(mean(modedData(riseEdge(edgeIndex):fallEdge(edgeIndex)-1))));
                    modedDataIndex = modedDataIndex+1;
                    edgeIndex = edgeIndex+1;
                    
                end
            
            %///////////
            %//No Edge//
            %///////////    
            else %keep moving, there is no edge
                
                modedDataIndex = modedDataIndex+1;    
            end
            
            
            
            
        end
        
        
        
    end
    
    
    %-----------------------------------------------
    
%/////////////
%//avg Width//
%/////////////
if riseEdge(1) == 0 %starts on a falling edge, so needs to skip first index for the rising edge
  for index = 2:1: length(fallEdge)-1
      if type == 0 %PWM
        widthArray(index) = (fallEdge(index)) - riseEdge(index);
      elseif type == 1 %PPM
           widthArray(index) = (fallEdge(index)-1) - riseEdge(index);
      end
      %do the index before the falling edge because is recorded on the low point
  end
  
  %check widthArray for errors
    %{
      for x = 1:1:length(widthArray)-1
          if widthArray(x)~=10 && type ==1
              disp(x);
          end  
      end
    %}  
  
  avgWidth = mean(widthArray(2:length(widthArray)-1));
  stdWidth = std(widthArray);
    
else
    for index = 1:1: length(fallEdge)-1
      if type == 0 %PWM
        widthArray(index) = (fallEdge(index)) - riseEdge(index);
      elseif type == 1 %PPM
           widthArray(index) = (fallEdge(index)-1) - riseEdge(index);
      end
      %do the index before the falling edge because is recorded on the low point
    end 
    
    %check widthArray for erros
    %{
      for x = 1:1:length(widthArray)-1
          if widthArray(x)~=10 && type ==1
              disp(x);
          end  
      end
    %}   
      
      
      
  avgWidth = mean(widthArray);
  stdWidth = std(widthArray);
end 


%/////////////////////////////////
%//Distance Between Rising Edges//
%/////////////////////////////////

if riseEdge(1) == 0 %starts on a falling edge, so needs to skip first index for the rising edge
  for index = 2:1: length(riseEdge)-1

        distBtRisingArray(index) = (riseEdge(index+1)) - riseEdge(index);

  end
  
  avgDistBtRising= mean(distBtRisingArray(2:length(distBtRisingArray)-1));
  stdDistBtRising = std(distBtRisingArray);
    
else
    for index = 1:1: length(riseEdge)-1
     
        distBtRisingArray(index) = (riseEdge(index+1)) - riseEdge(index);
      
      
    end 
      
  avgDistBtRising = mean(distBtRisingArray);
  stdDistBtRising = std(distBtRisingArray);
end 
% figure(20);
% plot(widthArray);
end

